<template>
  <!-- Filters -->
  <div class="pt-5">
    <filters
      v-model:model-value="filterInputs"
      :loading="loading"
      v-model:valid="isValidForm"
      @update:model-value="applyFilters"
      @reset="resetFilters"
    />
  </div>
  <div>
    <input-tooltip inline tooltip="Enable filtering the nodes that have GPU card supported only.">
      <v-switch
        color="primary"
        inset
        label="GPU Node (Only)"
        v-model="filterOptions.gpu"
        @update:model-value="updateGpu"
        hide-details
        :disabled="isFormLoading"
      />
    </input-tooltip>
  </div>
  <div class="pt-5">
    <v-card>
      <v-tabs v-model="activeTab" align-tabs="center">
        <v-tab v-for="(tab, index) in tabs" :key="index" :value="index" color="info">
          {{ tab.label }}
        </v-tab>
      </v-tabs>
    </v-card>
  </div>
  <div>
    <v-card class="pa-5">
      <v-data-table-server
        :loading="loading"
        :items-length="nodesCount"
        loading-text="Loading nodes..."
        :headers="headers"
        :items="nodes"
        v-model:items-per-page="filterOptions.size"
        v-model:expanded="expanded"
        show-expand
        :hide-no-data="false"
        :disable-sort="true"
        class="elevation-1"
        :hover="true"
        :items-per-page-options="[
          { value: 5, title: '5' },
          { value: 10, title: '10' },
          { value: 15, title: '15' },
          { value: 50, title: '50' },
        ]"
        v-model:page="filterOptions.page"
        return-object
      >
        <template v-slot:[`item.actions`]="{ item }">
          <reserve-btn :node="(item.raw as unknown as GridNode)" @updateTable="reloadTable" />
        </template>

        <template v-slot:[`item.price`]="{ item }">
          <v-tooltip bottom color="primary" close-delay="100">
            <template v-slot:activator="{ isActive, props }">
              <span v-bind="props" v-on="isActive">{{ item.raw.price }} *</span>
            </template>
            <span>
              Discounts: <v-spacer />
              <ul class="pl-2">
                <li>
                  You receive 50% discount if you reserve an entire
                  <a
                    target="_blank"
                    href="https://manual.grid.tf/dashboard/portal/dashboard_portal_dedicated_nodes.html#billing--pricing"
                  >
                    node
                  </a>
                </li>
                <li>
                  You're receiving {{ item.raw.discount }}% discount as per the
                  <a
                    target="_blank"
                    href="https://manual.grid.tf/wiki/cloudunits/pricing/staking_discount_levels.html#staking-discount-levels"
                  >
                    <p style="display: inline">staking discounts</p>
                  </a>
                </li>
              </ul>
            </span>
          </v-tooltip>
        </template>

        <template v-slot:expanded-row="{ columns, item }">
          <node-details :node="(item.raw as unknown as GridNode)" :columns-len="columns.length" />
        </template>
      </v-data-table-server>
    </v-card>
  </div>
</template>

<script setup lang="ts">
import type { GridNode } from "@threefold/gridproxy_client";
import { NodeStatus } from "@threefold/gridproxy_client";
import { CertificationType } from "@threefold/gridproxy_client";
import { onMounted, ref, watch } from "vue";
import type { VDataTable } from "vuetify/labs/VDataTable";
import { VDataTableServer } from "vuetify/labs/VDataTable";

import { gridProxyClient } from "@/clients";
import { useProfileManager } from "@/stores";
import { type FilterOptions, optionsInitializer } from "@/types";
import formatResourceSize from "@/utils/format_resource_size";
import { convert } from "@/utils/get_nodes";
import { getGrid } from "@/utils/grid";
import { toGigaBytes } from "@/utils/helpers";

const headers: VDataTable["headers"] = [
  { title: "Node ID", key: "nodeId", sortable: false },
  { title: "Location", key: "location.country", sortable: false },
  { title: "CPU", key: "total_resources.cru", sortable: false },
  {
    title: "RAM",
    key: "total_resources.mru",
    value: item => formatResourceSize(item.total_resources.mru),
    sortable: false,
  },
  {
    title: "SSD",
    key: "total_resources.sru",
    value: item => formatResourceSize(item.total_resources.sru),
    sortable: false,
  },
  {
    title: "HDD",
    key: "total_resources.hru",
    value: item => formatResourceSize(item.total_resources.hru),
    sortable: false,
  },
  { title: "GPU", key: "num_gpu", sortable: false },
  {
    title: "Price (USD)",
    key: "price",
    sortable: false,
  },
  {
    title: "Actions",
    key: "actions",
    sortable: false,
  },
];
const profileManager = useProfileManager();

const expanded = ref([]);
const tabs = [{ label: "Rentable" }, { label: "Mine" }];
const activeTab = ref(0);
const loading = ref(false);
const nodes = ref<any[]>();
const nodesCount = ref(0);
const filterInputs = ref<DedicatedNodeFilters>(DedicatedNodeInitializer());
const filterOptions = ref<FilterOptions>(optionsInitializer(undefined, undefined, undefined));

const isValidForm = ref<boolean>(false);
const isFormLoading = ref<boolean>(true);
const filtering = ref(false);

const tabParams = {
  0: {
    rentable: true,
    status: NodeStatus.Up,
    retCount: true,
  },
  1: {
    rented: true,
    rentedBy: profileManager.profile?.twinId,
    retCount: true,
  },
};

onMounted(async () => {
  await _loadData();
});
const updateGpu = (newGpu: boolean | undefined) => {
  if (!newGpu) {
    filterOptions.value.gpu = undefined;
  } else {
    filterOptions.value.gpu = newGpu;
  }
};
const _loadData = async () => {
  const params = tabParams[activeTab.value as keyof typeof tabParams];

  if (!params) {
    return;
  }

  loading.value = true;
  isFormLoading.value = true;
  try {
    const totalCruValue = filterInputs.value.total_cru.value;
    if (totalCruValue !== undefined && !Number.isInteger(+totalCruValue)) {
      loading.value = false;
      nodes.value = [];
      nodesCount.value = 0;
      isFormLoading.value = false;
      return;
    }
    const data = await gridProxyClient.nodes.list({
      ...params,
      size: filterOptions.value.size,
      page: filterOptions.value.page,
      totalSru: convert(filterInputs.value.total_sru.value),
      totalMru: convert(filterInputs.value.total_mru.value),
      totalHru: convert(filterInputs.value.total_hru.value),
      totalCru: totalCruValue ? +totalCruValue : undefined,
      gpuVendorName: filterInputs.value.gpu_vendor_name.value || "",
      gpuDeviceName: filterInputs.value.gpu_device_name.value || "",
      hasGpu: filterOptions.value.gpu,
    });

    if (data.count === 0) {
      loading.value = false;
      nodes.value = [];
      nodesCount.value = 0;
      isFormLoading.value = false;
      return;
    }

    const grid = await getGrid(profileManager.profile!);

    const pricePromises = data.data.map(async item => {
      const fee = await grid?.contracts.getDedicatedNodeExtraFee({ nodeId: item.nodeId });
      const price = await grid?.calculator.calculateWithMyBalance({
        cru: item.total_resources.cru,
        hru: toGigaBytes(item.total_resources.hru),
        mru: toGigaBytes(item.total_resources.mru),
        sru: toGigaBytes(item.total_resources.sru),
        ipv4u: false,
        certified: item.certificationType === CertificationType.Certified,
      });
      return {
        ...item,
        price: (price?.dedicatedPrice ?? 0 + (fee || 0)).toFixed(3),
        discount: price?.sharedPackage.discount ?? 0,
      };
    });

    const pricedNodes = await Promise.all(pricePromises);
    nodes.value = pricedNodes;

    nodesCount.value = data.count ?? 0;
    loading.value = false;
    isFormLoading.value = false;
  } catch (e) {
    console.log("Error: ", e);
    loading.value = false;
    isFormLoading.value = false;
  }
};

const applyFilters = async (filtersInputValues: DedicatedNodeFilters) => {
  filtering.value = true;
  filterInputs.value = filtersInputValues;
  filterOptions.value = optionsInitializer(undefined, filterOptions.value.gpu, filterOptions.value.gateway);
  if (isValidForm.value) {
    await _loadData();
  }
  filtering.value = false;
};
const resetFilters = async (filtersInputValues: DedicatedNodeFilters) => {
  filtering.value = true;
  filterInputs.value = filtersInputValues;
  filterOptions.value = optionsInitializer(undefined, undefined, undefined);
  if (isValidForm.value) {
    await _loadData();
  }
  filtering.value = false;
};
watch(
  [activeTab, filterOptions],
  async () => {
    if (!filtering.value) {
      await _loadData();
    }
  },
  { deep: true },
);
async function reloadTable() {
  await new Promise(resolve => {
    setTimeout(resolve, 20000);
  });
  await _loadData();
}
</script>

<script lang="ts">
import Filters from "@/components/filter.vue";
import { type DedicatedNodeFilters, DedicatedNodeInitializer } from "@/utils/filter_nodes";

import NodeDetails from "./node_details.vue";
import ReserveBtn from "./reserve_action_btn.vue";

export default {
  name: "Dedicated Node",
  components: {
    ReserveBtn,
    NodeDetails,
    Filters,
  },
};
</script>

<style>
.v-table__wrapper {
  min-height: 100px;
}

.v-tooltip > .v-overlay__content {
  pointer-events: initial !important;
}
</style>
